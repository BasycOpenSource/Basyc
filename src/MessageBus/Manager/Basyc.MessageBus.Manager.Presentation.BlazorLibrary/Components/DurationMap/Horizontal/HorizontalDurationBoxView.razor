@using Basyc.Blazor.Controls.Interops;
@using Basyc.MessageBus.Manager.Presentation.BlazorLibrary.Components.LogIcon
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using System.Collections.ObjectModel;
@using Basyc.Blazor.Controls.HtmlExtensions
@using Microsoft.Extensions.Logging;
@using Throw
@using Basyc.MessageBus.Manager.Application.ResultDiagnostics
@using Color = Basyc.Blazor.Controls.Colors.Color
@using static Basyc.MessageBus.Manager.Presentation.BlazorLibrary.Components.DurationMap.Horizontal.LogAggregator;
@implements IDisposable
@implements IHandleEvent


<horizontalDurationBoxView @ref=horizontalDurationBoxView>
    <BasycTooltip>
        <TooltipContent>
            <DurationBoxToolTip Name="@Activity.DisplayName"
                                Service="@Activity.Service"
                                StartTime="@Activity.StartTime"
                                Duration="((Activity.EndTime.Value - Activity.StartTime.Value))"
                                ActivityContext="@Activity" />
        </TooltipContent>
        <ChildContent>
            <durationBox @ref=durationBoxRef>
                <stickyContainer>
                    <acitvityName @ref=activityNameRef>
                        @Activity.DisplayName
                    </acitvityName>
                    @if (Activity.HasEnded is false)
                    {
                        <spinner>
                            <MudProgressCircular Color="MudBlazor.Color.Default" Indeterminate="true" Size="Size.Small" />
                        </spinner>
                    }
                </stickyContainer>
                <logs>
                    <Virtualize Items="@AggragatedLogs"
                                Context="aggregatedLog"
                                ItemSize="0.001F">
                        <ItemContent>
                            @{
                                var logContentClass = $"logContent--{aggregatedLog.WorstLogLevel}";
                                var logTimeStartCss = Math.Round((aggregatedLog.Time - Activity.StartTime.AbsoluteTime).TotalMilliseconds);
                                var logStyle = $"--logTimeStartCss: {logTimeStartCss}";
                            }
                            <log style="@logStyle">
                                <MudTooltip RootClass="logContentToolTip">
                                    <ChildContent>
                                        <LogIconView LogLevel="aggregatedLog.WorstLogLevel" />
                                    </ChildContent>
                                    <TooltipContent>
                                        <toolTipContent>
                                            @string.Join(", ", aggregatedLog.Logs.Select(x => x.Message))
                                        </toolTipContent>
                                    </TooltipContent>
                                </MudTooltip>
                            </log>
                        </ItemContent>
                        <Placeholder>
                            <loading />
                        </Placeholder>

                    </Virtualize>
                </logs>

            </durationBox>
        </ChildContent>
    </BasycTooltip>

    <nestedDurationBoxes>
        @{
            List<RowViewModel> rows = new();
            rows.Add(new RowViewModel());
            foreach (var nestedActivity in Activity.NestedActivities.OrderBy(x => x.StartTime))
            {
                var nestedActivityLatestEndTime = GetRecursiveLatestEndTime(nestedActivity);
                var lastRow = rows.Last();
                if (lastRow.LastEndTime == default)
                {
                    lastRow.Activities.Add(nestedActivity);
                    lastRow.LastEndTime = nestedActivityLatestEndTime;
                    lastRow.StartTime = nestedActivity.StartTime.AbsoluteTime;
                    continue;
                }
                var previousActivityInRow = lastRow.Activities.First();
                var diff = Math.Ceiling((nestedActivity.StartTime.AbsoluteTime - lastRow.LastEndTime).TotalMilliseconds);
                var canFitOnSameRow = diff >= 0;
                var startsTheSameAndPreviousHas0Duration = (lastRow.LastEndTime - nestedActivity.StartTime.AbsoluteTime).TotalMilliseconds == 0 && previousActivityInRow.Duration.Ticks == 0;
                if (canFitOnSameRow || startsTheSameAndPreviousHas0Duration)
                {
                    lastRow.Activities.Add(nestedActivity);
                    lastRow.LastEndTime = nestedActivityLatestEndTime;
                }
                else
                {
                    var newRow = new RowViewModel();
                    newRow.LastEndTime = nestedActivityLatestEndTime;
                    newRow.Activities.Add(nestedActivity);
                    newRow.StartTime = nestedActivity.StartTime.AbsoluteTime;
                    rows.Add(newRow);
                }
            }

            RowViewModel? previousRow = null;
            foreach (var row in rows)
            {
                ActivityContext? previousRowActivity = null;
                if (previousRow != null)
                {
                    <rowSplitter />
                }
                <nestedRows>
                    @if (rows.Count > 1)
                    {
                        <treeLeg>
                            <treeHorizontalLine />
                        </treeLeg>
                    }
                    @foreach (var nestedActivity in row.Activities)
                    {
                        <nestedRow>
                            @{
                                var isFirstNested = previousRowActivity is null;
                                if (isFirstNested)
                                {
                                    var lateStartDuration = nestedActivity.StartTime.AbsoluteTime - Activity.StartTime.AbsoluteTime;
                                    if (lateStartDuration > TimeSpan.FromMilliseconds(0))
                                    {
                                        <HorizontalUnknownDurationBoxView StartTime="Activity.StartTime.AbsoluteTime" EndTime="nestedActivity.StartTime.AbsoluteTime" Color="@Color" />
                                    }
                                }


                                var isGapBetweenPreviousNested = previousRowActivity is not null && previousRowActivity.EndTime.Value != nestedActivity.StartTime.Value; ;
                                if (isGapBetweenPreviousNested)
                                {
                                    previousRowActivity.ThrowIfNull();
                                    <HorizontalUnknownDurationBoxView StartTime="previousRowActivity.EndTime.AbsoluteTime" EndTime="nestedActivity.StartTime.AbsoluteTime" Color="@Color" />
                                }
                                <HorizontalDurationBoxView DurationMapRenderContext="DurationMapRenderContext" Activity="nestedActivity" Color="@Color" NestingLevel="NestingLevel+1" />

                                previousRowActivity = nestedActivity;

                            }
                        </nestedRow>
                    }
                </nestedRows>
                previousRow = row;
            }

        }
    </nestedDurationBoxes>

</horizontalDurationBoxView>


@code {

    private ElementReference horizontalDurationBoxView;
    private ElementReference durationBoxRef;
    private ElementReference activityNameRef;
    private bool isRendered = false;

    [Inject] public ILogger<HorizontalDurationBoxView> logger { get; init; } = null!;
    [Inject] public ElementJsInterop ElementJsInterop { get; init; } = null!;

    [Parameter]
    [EditorRequired]
    public DurationMapRenderContext DurationMapRenderContext { get; set; } = null!;

#pragma warning disable BL0007
    private ActivityContext activity = null!;
    [Parameter]
    [EditorRequired]
    public ActivityContext Activity
    {
        get => activity;
        set
        {
            if (activity != null)
            {
                activity.ActivityEnded -= OnActivityEnded;
                activity.NestedActivityEnded -= OnNestedActivityEnded;
                activity.LogAdded -= OnLogAdded;
            }
            activity = value;
        }
    }
#pragma warning restore BL0007
    [Parameter]
    [EditorRequired]
    public Color Color { get; set; }

    [Parameter]
    [EditorRequired]
    public int NestingLevel { get; set; }

    private const double logWidthMultiplier = 4;
    private const double logMinWidthPixels = 5;
    private const double logMaxWidthPixels = 10;
    private ReadOnlyCollection<AggregatedLog> AggragatedLogs = new ReadOnlyCollection<AggregatedLog>(new List<AggregatedLog>());

    //protected override async Task OnParametersSetAsync()
    //{
    //    logger.LogDebug("OnParametersSetAsync");

    //    isRendered = false;
    //    Activity.ActivityEnded += OnActivityEnded;
    //    Activity.NestedActivityEnded += OnNestedActivityEnded;
    //    Activity.LogAdded += OnLogAdded;
    //    DurationMapRenderContext.FastTimer -= OnFastTimer;
    //    DurationMapRenderContext.FastTimer += OnFastTimer;
    //    AggragatedLogs = LogAggregator.AggregateLogs(Activity.Logs, DurationMapRenderContext.PixelsPerMs, logMinWidthPixels, logMaxWidthPixels, logWidthMultiplier);

    //    await base.OnParametersSetAsync();
    //}

    protected override void OnParametersSet()
    {
        logger.LogDebug("OnParametersSet");
        //isRendered = false;
        Activity.ActivityEnded += OnActivityEnded;
        Activity.NestedActivityEnded += OnNestedActivityEnded;
        Activity.LogAdded += OnLogAdded;
        DurationMapRenderContext.FastTimer -= OnFastTimer;
        DurationMapRenderContext.FastTimer += OnFastTimer;
        DurationMapRenderContext.MediumTimer -= OnMediumTimer;
        DurationMapRenderContext.MediumTimer += OnMediumTimer;
        logger.LogDebug("OnFastTimer added");

        AggragatedLogs = LogAggregator.AggregateLogs(Activity.Logs, DurationMapRenderContext.PixelsPerMs, logMinWidthPixels, logMaxWidthPixels, logWidthMultiplier);
        base.OnParametersSet();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
            isRendered = true;
        base.OnAfterRender(firstRender);
    }

    Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, object? arg) => callback.InvokeAsync(arg);

    private async Task SetTimeCssVar(TimeSpan timeSpan)
    {
        var timeSpanMs = Html.Methods.Number(timeSpan.TotalMilliseconds);
        await ElementJsInterop.SetCssVariable(horizontalDurationBoxView, DurationMapConstants.TimeSpanCssVarName, timeSpanMs);
    }

    private void OnActivityEnded(object? sender, EventArgs e) => StateHasChanged();

    private void OnNestedActivityEnded(object? sender, EventArgs e) => StateHasChanged();

    public void Dispose()
    {
        isRendered = false;
        logger.LogDebug("Dispose");

        Activity.ActivityEnded -= OnActivityEnded;
        Activity.NestedActivityEnded -= OnNestedActivityEnded;
        Activity.LogAdded -= OnLogAdded;
        DurationMapRenderContext.FastTimer -= OnFastTimer;
        DurationMapRenderContext.MediumTimer -= OnMediumTimer;

    }

    private static DateTimeOffset GetRecursiveLatestEndTime(ActivityContext activity)
    {
        var latestEndTime = activity.EndTime.AbsoluteTime;
        foreach (var nestedActivity in activity.NestedActivities)
        {
            var nestedLatestEndTime = GetRecursiveLatestEndTime(nestedActivity);
            latestEndTime = latestEndTime > nestedLatestEndTime ? latestEndTime : nestedLatestEndTime;
        }
        return latestEndTime;
    }

    private void OnLogAdded(object? sender, EventArgs e)
    {
        if (isRendered is false)
            return;
        UpdateAggregatedLogs();
    }

    private async void OnFastTimer(object? sender, EventArgs e)
    {
        await UpdateTime();
    }

    private void OnMediumTimer(object? sender, EventArgs e)
    {
        if (isRendered is false)
            return;
        UpdateAggregatedLogs();
    }

    private void UpdateAggregatedLogs()
    {
        //TODO: When log added, its forces to rerender all nested duration boxes -> move logging row to new blazor component.
        var newAggragatedLogs = LogAggregator.AggregateLogs(Activity.Logs, DurationMapRenderContext.PixelsPerMs, logMinWidthPixels, logMaxWidthPixels, logWidthMultiplier);
        if (newAggragatedLogs.Count == AggragatedLogs.Count)
            return;
        AggragatedLogs = newAggragatedLogs;
        StateHasChanged();

    }

    private async Task UpdateTime()
    {
        logger.LogDebug("UpdateTime");

        if (isRendered is false)
            return;

        logger.LogDebug("UpdateTime isRendered true");

        if (Activity.HasEnded)
        {
            await SetTimeCssVar(Activity.EndTime.AbsoluteTime - Activity.StartTime.AbsoluteTime);
            DurationMapRenderContext.FastTimer -= OnFastTimer;
            DurationMapRenderContext.MediumTimer -= OnMediumTimer;
        }
        else
        {
            await SetTimeCssVar(DateTimeOffset.UtcNow - Activity.StartTime.AbsoluteTime);
        }
    }



    private class RowViewModel
    {
        public DateTimeOffset StartTime { get; set; } = default;
        public DateTimeOffset LastEndTime { get; set; } = default;
        public List<ActivityContext> Activities { get; } = new();
    }

}
