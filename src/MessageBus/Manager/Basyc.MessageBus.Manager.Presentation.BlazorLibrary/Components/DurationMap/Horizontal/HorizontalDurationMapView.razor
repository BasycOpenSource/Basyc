@using Basyc.Blazor.Controls.HtmlExtensions;
@using Basyc.Blazor.Controls.Interops;
@using Basyc.Diagnostics.Shared.Logging
@using Basyc.MessageBus.Manager.Application
@using Basyc.MessageBus.Manager.Application.ResultDiagnostics
@using Basyc.MessageBus.Manager.Presentation.BlazorLibrary.Components.DurationMap;
@using Basyc.Blazor.Controls.Colors;
@using Microsoft.Extensions.Logging;
@implements IHandleEvent;
@implements IDisposable;



<horizontalDurationMapView @ref=horizontalDurationMapViewRef>
    <zoomToolBarRow>
        @*<MudNumericField Format="N2" T="double" @bind-Value="PixelsPerMs" FullWidth="false" Step="10" Style="color: white;" />*@
        <button class="toolBarButton" @onclick="@OnZoomInClick">+</button>
        <button class="toolBarButton" @onclick="@OnZoomOutClick">-</button>
        <button class="toolBarButton" @onclick="@OnZoomFitClick">fit</button>
    </zoomToolBarRow>
    <servicesRow id="@scrollId">
        @{
            if (RequestContext.Diagnostics.Services.Any())
            {
                foreach (var service in RequestContext.Diagnostics.Services.Where(x => x.Activities.Any()).OrderBy(x => x.Activities.Min(y => y.StartTime)))
                {
                    var serviceThemeColor = ServiceColorHelper.GetBackground(service.ServiceIdentity.ServiceName);

                    var nameColor = serviceThemeColor.Edit(opacity: 0.3);
                    var borderColor = serviceThemeColor.Edit(opacity: 0.25);
                    var backgroundColor = serviceThemeColor.Edit(opacity: 0.05);

                    var serviceFirstActivity = service.Activities.First();
                    var serviceStyle = $"background-color: {backgroundColor}";
                    var durationBoxesStyle = $"margin-left: {DurationViewHelper.GetCssDurationValue(RequestContext.StartTime, serviceFirstActivity.StartTime.AbsoluteTime, PixelsPerMs)};";
                    var serviceNameStyle = $"color: {nameColor}";
                    <service style="@serviceStyle">
                        <serviceNameContainer>
                            <serviceName style="@serviceNameStyle">
                                @service.ServiceIdentity.ServiceName
                            </serviceName>
                        </serviceNameContainer>
                        <durationBoxes style="@durationBoxesStyle">
                            @{
                                ActivityContext? previousActivity = null;
                                foreach (var activity in service.Activities)
                                {
                                    <unknownAndKnowGroup>
                                        @{
                                            var leftMargin = previousActivity == null ? "0px" : DurationViewHelper.GetCssDurationValue(serviceFirstActivity.StartTime.Value, activity.StartTime.Value, PixelsPerMs);
                                            <div style="display: flex; margin-left:@leftMargin;">
                                                @{
                                                    <HorizontalDurationBoxView DurationMapRenderContext="durationMapRenderContext" Activity="activity" Color="@serviceThemeColor" NestingLevel="0" />
                                                    previousActivity = activity;
                                                }
                                            </div>
                                        }
                                    </unknownAndKnowGroup>
                                }
                            }
                        </durationBoxes>
                    </service>
                    <br>
                }
            }
        }
    </servicesRow>
</horizontalDurationMapView>

@code {
    private bool isRendered = false;
    private bool updatePixelsPerMsCssVarInOnAfterRender = false;
    private ElementReference horizontalDurationMapViewRef;
    private DurationMapRenderContext durationMapRenderContext = new();
    [Inject] private BusManagerJsInterop BusManagerJsInterop { get; set; } = null!;
    [Inject] private ScrollJsInterop ScrollJsInterop { get; set; } = null!;
    [Inject] public ElementJsInterop ElementJsInterop { get; init; } = null!;
    [Inject] private ILogger<HorizontalDurationMapView> Logger { get; init; } = null!;

    private PeriodicTimer? fastTimer;
    private bool zoomManuallyChanged;


    [Parameter]
    [EditorRequired]
    public MessageRequest RequestContext { get; set; } = null!;

    [Parameter]
    public double PixelsPerMs { get; set; } = 1;

#pragma warning disable CA5394
    private string scrollId = Random.Shared.Next().ToString();
#pragma warning restore CA5394

    protected override void OnInitialized()
    {
        durationMapRenderContext.FastTimer -= OnFastTimer;
        durationMapRenderContext.FastTimer += OnFastTimer;
        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        isRendered = true;
        Logger.LogDebug("OnAfterRenderAsync");
        if (firstRender)
        {
            ScrollJsInterop.AddDragToScroll(scrollId);            
        }
        if (updatePixelsPerMsCssVarInOnAfterRender)
        {
            await ElementJsInterop.SetCssVariable(horizontalDurationMapViewRef, DurationMapConstants.PixelsPerMs, Html.Methods.Number(PixelsPerMs));
            updatePixelsPerMsCssVarInOnAfterRender = false;
        }
        StartTimers();
        await base.OnAfterRenderAsync(firstRender);
    }

    protected override void OnParametersSet()
    {
        isRendered = false;
        Logger.LogDebug("OnParametersSet");
        StopTimers();
        RequestContext.Diagnostics.ActivityStartAdded -= OnActivityStartAdded;
        RequestContext.Diagnostics.ActivityStartAdded += OnActivityStartAdded;
        RequestContext.Diagnostics.ActivityEndAdded -= OnActivityEneAdded;
        RequestContext.Diagnostics.ActivityEndAdded += OnActivityEneAdded;
        if (PixelsPerMs != durationMapRenderContext.PixelsPerMs)
        {
            updatePixelsPerMsCssVarInOnAfterRender = true;
            durationMapRenderContext.PixelsPerMs = PixelsPerMs;

        }

        base.OnParametersSet();
    }

    public void Dispose()
    {
        isRendered = false;
        Logger.LogDebug("Dispose");
        RequestContext.Diagnostics.ActivityStartAdded -= OnActivityStartAdded;
        RequestContext.Diagnostics.ActivityEndAdded -= OnActivityEneAdded;
        StopTimers();
    }

    Task IHandleEvent.HandleEventAsync(
    EventCallbackWorkItem callback, object? arg) => callback.InvokeAsync(arg);

    private void OnActivityStartAdded(object? sender, ActivityStart activityStart) => StateHasChanged();

    private void OnActivityEneAdded(object? sender, ActivityEnd activityEnd) => StateHasChanged();

    private async Task OnZoomInClick(MouseEventArgs args)
    {
        zoomManuallyChanged = true;
        PixelsPerMs += 0.1 * PixelsPerMs * 3;
        durationMapRenderContext.PixelsPerMs = PixelsPerMs;
        await ElementJsInterop.SetCssVariable(horizontalDurationMapViewRef, DurationMapConstants.PixelsPerMs, Html.Methods.Number(PixelsPerMs));
    }

    private async Task OnZoomOutClick(MouseEventArgs args)
    {
        zoomManuallyChanged = true;
        PixelsPerMs -= 0.1 * PixelsPerMs * 3;
        if (PixelsPerMs < 0)
            PixelsPerMs = 0;
        durationMapRenderContext.PixelsPerMs = PixelsPerMs;
        await ElementJsInterop.SetCssVariable(horizontalDurationMapViewRef, DurationMapConstants.PixelsPerMs, Html.Methods.Number(PixelsPerMs));
    }

    private async Task OnZoomFitClick(MouseEventArgs args)
    {
        zoomManuallyChanged = false;
        await ZoomFit();
    }

    private async Task ZoomFit()
    {
        //Logger.LogDebug("ZoomFit");

        double aviableWidthPx = 1000; //this can be dynamic value obtained from js
        DurationViewHelper.GetCssDurationValue(GetLatestEndTime(RequestContext.Diagnostics) - RequestContext.StartTime, 1, out var normalWidthPx);
        var newPixelsPerMs = aviableWidthPx / normalWidthPx;
        if (newPixelsPerMs != PixelsPerMs)
        {
            PixelsPerMs = newPixelsPerMs;
            durationMapRenderContext.PixelsPerMs = PixelsPerMs;

            if (isRendered is false)
                return;
            //Logger.LogDebug("ZoomFit SetCssVariable");
            await ElementJsInterop.SetCssVariable(horizontalDurationMapViewRef, DurationMapConstants.PixelsPerMs, Html.Methods.Number(PixelsPerMs));
        }
    }

    private static DateTimeOffset GetLatestEndTime(MessageDiagnostic requestDiagnostic)
    {
        static DateTimeOffset GetLatestEndTimeFromActivity(ActivityContext activity)
        {
            if (activity.Status == System.Diagnostics.ActivityStatusCode.Unset)
                return DateTimeOffset.UtcNow;

            var latestEndTime = activity.EndTime;
            foreach (var nestedActivity in activity.NestedActivities)
            {

                var nestedLatestEndTime = GetLatestEndTimeFromActivity(nestedActivity).GetDiagnosticTime(latestEndTime.BaseTime);
                latestEndTime = latestEndTime.Value > nestedLatestEndTime.Value ? latestEndTime : nestedLatestEndTime;
            }
            return latestEndTime.AbsoluteTime;
        }

        DateTimeOffset latestEndTime = default;
        foreach (var service in requestDiagnostic.Services)
        {
            foreach (var activity in service.Activities)
            {
                foreach (var nestedActivity in activity.NestedActivities)
                {
                    var nestedLatestEndTime = GetLatestEndTimeFromActivity(nestedActivity);
                    latestEndTime = latestEndTime > nestedLatestEndTime ? latestEndTime : nestedLatestEndTime;
                }
            }
        }

        return latestEndTime;
    }

    private async void OnFastTimer(object? sender, EventArgs args)
    {
        if (zoomManuallyChanged is false)
            await ZoomFit();
    }

    private async void StartTimers()
    {
        Logger.LogDebug(nameof(StartTimers));
        durationMapRenderContext.OnFastTimer();

        if (fastTimer is not null)
            StopTimers();

        fastTimer = new PeriodicTimer(TimeSpan.FromSeconds(0.05));
        int ticksInGroup = 0;
        while (await fastTimer.WaitForNextTickAsync())
        {
            ticksInGroup++;
            if (isRendered is false)
                continue;
            durationMapRenderContext.OnFastTimer();

            if (ticksInGroup == 10)
            {
                durationMapRenderContext.OnMediumTimer();
                ticksInGroup = 0;
            }
           
        }
    }

    private void StopTimers()
    {
        Logger.LogDebug(nameof(StopTimers));

        fastTimer?.Dispose();
        fastTimer = null;
    }
}
